void printArray(int A[], int n) {
    int i;
    i = 0;
    while (i < n) {
        output(A[i]);
        i = i + 1;
    }
}

int Div(int a, int b, int q) {
    int biggestPow2;
    if (b == 0) {
        return 0;
    } else {
        if (a < b) {
            return q;
        } else {
            biggestPow2 = 1;
            while (biggestPow2 * b * 2 < a + 1) {
                biggestPow2 = 2 * biggestPow2;
            }
            q = q + biggestPow2;
            return Div(a - biggestPow2 * b, b, q);
        }
    }
}

int Mod(int a, int b) {
    return a - b * Div(a, b, 0);
}

int Or(int a, int b) {
    int tmp1;
    int tmp2;
    int msk;
    int ans;
    msk = 1;
    ans = 0;
    while (1) {
        if (((a < msk) + (b < msk)) == 2) {
            break;
        } else {
            tmp1 = Mod(a, msk * 2);
            tmp2 = Mod(b, msk * 2);
            tmp1 = (msk < (tmp1 + 1));
            tmp2 = (msk < (tmp2 + 1));
            tmp1 = (0 < (tmp1 + tmp2));
            ans = ans + tmp1 * msk;
        }
        msk = msk * 2;
    }
    return ans;
}

int And(int a, int b) {
    int tmp1;
    int tmp2;
    int msk;
    int ans;
    msk = 1;
    ans = 0;
    while (1) {
        if (((a < msk) + (b < msk)) == 2) {
            break;
        } else {
            tmp1 = Mod(a, msk * 2);
            tmp2 = Mod(b, msk * 2);
            tmp1 = (msk < (tmp1 + 1));
            tmp2 = (msk < (tmp2 + 1));
            tmp1 = ((tmp1 + tmp2) == 2);
            ans = ans + tmp1 * msk;
        }
        msk = msk * 2;
    }
    return ans;
}

int Xor(int a, int b) {
    return Or(a, b) - And(a, b);
}

int Power(int a, int b) {
    int tmp1;
    int tmp2;
    if (b == 0) {
        return 1;
    } else if (b == 1) {
        return a;
    } else {
        tmp1 = Mod(b, 2);
        tmp2 = Div(b, 2, 0);
        tmp2 = Power(a, tmp2);
        return tmp2 * tmp2 * Power(a, tmp1);
    }
}

int SQRT(int a, int b) {
    int l;
    int r;
    int mid;
    l = 0;
    r = a + 1;
    while (1 < r - l) {
        mid = Div(r + l, 2, 0);
        if (a < Power(mid, b)) {
            r = mid;
        } else {
            l = mid;
        }
    }
    return l;
}

void BinaryPrint(int a) {
    int Length;
    int Ar[1024];
    int i;
    int tmp;
    int ans;
    Length = 16;
    i = 0;
    ans = 0;
    while (a > 0) {
        tmp = Mod(a, 2);
        a = Div(a, 2, 0);
        Ar[i] = tmp;
        i = i + 1;
    }
    while (i > 0) {
        i = i - 1;
        ans = ans * 10 + Ar[i];
    }
    output(ans);
}


void buildTree(int node, int start, int end, int base[], int tree[]) {
    int mid;
    int leftChild;
    int rigtChild;
    if (start == end) {
        tree[node] = base[start];
    } else {
        mid = Div(start + end, 2, 0);
        leftChild = 2 * node;
        rigtChild = 2 * node + 1;
        buildTree(leftChild, start, mid, base, tree);
        buildTree(rigtChild, mid + 1, end, base, tree);
        tree[node] = tree[leftChild] + tree[rigtChild];
    }
}

void updateTree(int node, int start, int end, int idx, int val, int base[], int tree[]) {
    int mid;
    int leftChild;
    int rigtChild;
    if (start == end) {
        base[idx] = val;
        tree[node] = val;
    } else {
        mid = Div(start + end, 2, 0);
        leftChild = 2 * node;
        rigtChild = 2 * node + 1;
        if (idx < mid + 1) {
            updateTree(leftChild, start, mid, idx, val, base, tree);
        } else {
            updateTree(rigtChild, mid + 1, end, idx, val, base, tree);
        }
        tree[node] = tree[leftChild] + tree[rigtChild];
    }
}

int queryTree(int node, int start, int end, int l, int r, int tree[]) {
    int mid;
    int leftChild;
    int rigtChild;
    int leftSum;
    int rightSum;
    int tmp ; 
    if (((r < start) + (end < l))) {
        return 0;
    }
    else if (((l < start+1) * (end < r + 1 ))) {
        return tree[node];
    }
    else {
        tmp = tmp ; 
    }
    mid = Div(start + end, 2, 0);
    leftChild = 2 * node;
    rigtChild = 2 * node + 1;
    leftSum = queryTree(leftChild, start, mid, l, r, tree);
    rightSum = queryTree(rigtChild, mid + 1, end, l, r, tree);
    return leftSum + rightSum;
}

void main(void) {
    int a;
    int b;
    int base[16];
    int tree[64];
    int i;
    int n;

    a = 7;
    b = 3;
    BinaryPrint(a);
    BinaryPrint(b);
    BinaryPrint(Or(a, b));
    BinaryPrint(And(a, b));
    BinaryPrint(Xor(a, b));

    output(Power(3, 3));
    output(SQRT(999, 3));

    n = 16;

    i = 0;
    while (i < n) {
        output(a);
        base[i] = i + 1;
        i = i + 1;
    }

    buildTree(1, 0, n - 1, base, tree);

    output(queryTree(1, 0, n - 1, 0, n - 1, tree));

    updateTree(1, 0, n - 1, 3, 10, base, tree);

    output(queryTree(1, 0, n - 1, 0, n - 1, tree));

    output(queryTree(1, 0, n - 1, 0, 3, tree));
}